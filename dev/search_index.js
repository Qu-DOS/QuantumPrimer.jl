var documenterSearchIndex = {"docs":
[{"location":"cost/#Cost-documentation","page":"Cost","title":"Cost documentation","text":"","category":"section"},{"location":"cost/","page":"Cost","title":"Cost","text":"AbstractCost\nGeneralCost\nCircuitCost","category":"page"},{"location":"cost/#QuantumPrimer.AbstractCost","page":"Cost","title":"QuantumPrimer.AbstractCost","text":"AbstractCost\n\nAn abstract type for representing cost functions in quantum circuits.\n\n\n\n\n\n","category":"type"},{"location":"cost/#QuantumPrimer.GeneralCost","page":"Cost","title":"QuantumPrimer.GeneralCost","text":"GeneralCost{FF<:Function, AA<:Function}\n\nA struct representing a general cost function with an optional activation function.\n\nFields\n\ncost::FF: The cost function.\nactivation::AA: The activation function, default is identity.\n\nConstructor\n\nGeneralCost(cost::FF, activation::AA=identity): Creates a GeneralCost instance.\n\n\n\n\n\n","category":"type"},{"location":"cost/#QuantumPrimer.CircuitCost","page":"Cost","title":"QuantumPrimer.CircuitCost","text":"CircuitCost{FF<:Function, AA<:Function}\n\nA struct representing a circuit-specific cost function with an optional activation function.\n\nFields\n\ncost::FF: The cost function.\nactivation::AA: The activation function, default is identity.\n\nConstructor\n\nCircuitCost(cost::FF, activation::AA=identity): Creates a CircuitCost instance.\n\n\n\n\n\n","category":"type"},{"location":"data/#Data-documentation","page":"Data","title":"Data documentation","text":"","category":"section"},{"location":"data/","page":"Data","title":"Data","text":"AbstractData\nData\nDataSiamese","category":"page"},{"location":"data/#QuantumPrimer.AbstractData","page":"Data","title":"QuantumPrimer.AbstractData","text":"AbstractData\n\nAn abstract type for representing data in quantum machine learning.\n\n\n\n\n\n","category":"type"},{"location":"data/#QuantumPrimer.Data","page":"Data","title":"QuantumPrimer.Data","text":"Data{S <: Vector{SS} where SS <: ArrayReg, L <: Vector{LL} where LL <: Real}\n\nA struct representing a dataset with quantum states and corresponding labels.\n\nFields\n\nstates::S: A vector of quantum states.\nlabels::L: A vector of labels corresponding to the quantum states.\n\nConstructor\n\nData(states::S, labels::L): Creates a Data instance.\n\n\n\n\n\n","category":"type"},{"location":"data/#QuantumPrimer.DataSiamese","page":"Data","title":"QuantumPrimer.DataSiamese","text":"DataSiamese{S <: Vector{NTuple{2, SS}} where SS <: ArrayReg, L <: Vector{LL} where LL <: Real}\n\nA struct representing a dataset for Siamese networks with pairs of quantum states and corresponding labels.\n\nFields\n\nstates::S: A vector of tuples, each containing a pair of quantum states.\nlabels::L: A vector of labels corresponding to the pairs of quantum states.\n\nConstructor\n\nDataSiamese(states::S, labels::L): Creates a DataSiamese instance.\n\n\n\n\n\n","category":"type"},{"location":"qnn/#QNN-documentation","page":"QNN","title":"QNN documentation","text":"","category":"section"},{"location":"qnn/","page":"QNN","title":"QNN","text":"build_QNN","category":"page"},{"location":"qnn/#QuantumPrimer.build_QNN","page":"QNN","title":"QuantumPrimer.build_QNN","text":"build_QNN(n::Int, depth::Int; ansatz=circ_HEA::Function) -> ChainBlock\n\nBuilds a Quantum Neural Network (QNN) circuit.\n\nArguments\n\nn::Int: The number of qubits.\ndepth::Int: The depth of the QNN, i.e., the number of layers.\nansatz::Function: The ansatz function to use for each layer, default is circ_HEA.\n\nReturns\n\nChainBlock: The constructed QNN circuit.\n\n\n\n\n\n","category":"function"},{"location":"activation/#Activation-functions-documentation","page":"Activation","title":"Activation functions documentation","text":"","category":"section"},{"location":"activation/#Functions","page":"Activation","title":"Functions","text":"","category":"section"},{"location":"activation/","page":"Activation","title":"Activation","text":"sigmoid\nhyperbolic_tangent","category":"page"},{"location":"activation/#QuantumPrimer.sigmoid","page":"Activation","title":"QuantumPrimer.sigmoid","text":"sigmoid(x::Real, a::Real, b::Real) -> Real\n\nComputes the sigmoid function with parameters a and b.\n\nArguments\n\nx::Real: The input value.\na::Real: The slope parameter.\nb::Real: The shift parameter.\n\nReturns\n\nReal: The computed sigmoid value.\n\n\n\n\n\nsigmoid(x::Real) -> Real\n\nComputes the sigmoid function with default parameters a = 1 and b = 0.\n\nArguments\n\nx::Real: The input value.\n\nReturns\n\nReal: The computed sigmoid value.\n\n\n\n\n\n","category":"function"},{"location":"activation/#QuantumPrimer.hyperbolic_tangent","page":"Activation","title":"QuantumPrimer.hyperbolic_tangent","text":"hyperbolic_tangent(x::Real, a::Real, b::Real) -> Real\n\nComputes the hyperbolic tangent function with parameters a and b.\n\nArguments\n\nx::Real: The input value.\na::Real: The slope parameter.\nb::Real: The shift parameter.\n\nReturns\n\nReal: The computed hyperbolic tangent value.\n\n\n\n\n\n","category":"function"},{"location":"loss/#Loss-documentation","page":"Loss","title":"Loss documentation","text":"","category":"section"},{"location":"loss/#Loss-evaluation","page":"Loss","title":"Loss evaluation","text":"","category":"section"},{"location":"loss/","page":"Loss","title":"Loss","text":"eval_loss\neval_full_loss","category":"page"},{"location":"loss/#QuantumPrimer.eval_loss","page":"Loss","title":"QuantumPrimer.eval_loss","text":"eval_loss(state::ArrayReg, model::AbstractModel, cost::GeneralCost; lambda=1.0::Float64, regularization=:nothing::Symbol) -> Float64\n\nEvaluates the loss for a given quantum state and model using a general cost function.\n\nArguments\n\nstate::ArrayReg: The quantum state.\nmodel::AbstractModel: The quantum model.\ncost::GeneralCost: The general cost function.\nlambda::Float64: The regularization parameter, default is 1.0.\nregularization::Symbol: The type of regularization (:l1 or :l2), default is :nothing.\n\nReturns\n\nFloat64: The evaluated loss.\n\n\n\n\n\neval_loss(state::ArrayReg, model::AbstractModel, cost::CircuitCost; lambda=1.0::Float64, regularization=:nothing::Symbol) -> Float64\n\nEvaluates the loss for a given quantum state and model using a circuit cost function.\n\nArguments\n\nstate::ArrayReg: The quantum state.\nmodel::AbstractModel: The quantum model.\ncost::CircuitCost: The circuit cost function.\nlambda::Float64: The regularization parameter, default is 1.0.\nregularization::Symbol: The type of regularization (:l1 or :l2), default is :nothing.\n\nReturns\n\nFloat64: The evaluated loss.\n\n\n\n\n\neval_loss(states::NTuple{2, ArrayReg}, models::NTuple{2, AbstractModel}, cost::CircuitCost; lambda=1.0::Float64, regularization=:nothing::Symbol) -> Float64\n\nEvaluates the loss for a pair of quantum states and models using a circuit cost function.\n\nArguments\n\nstates::NTuple{2, ArrayReg}: The tuple of quantum states.\nmodels::NTuple{2, AbstractModel}: The tuple of quantum models.\ncost::CircuitCost: The circuit cost function.\nlambda::Float64: The regularization parameter, default is 1.0.\nregularization::Symbol: The type of regularization (:l1 or :l2), default is :nothing.\n\nReturns\n\nFloat64: The evaluated loss.\n\n\n\n\n\neval_loss(states::NTuple{2, ArrayReg}, models::NTuple{<:Any, AbstractModel}, cost::CircuitCost; lambda=1.0::Float64, regularization=:nothing::Symbol) -> Float64\n\nEvaluates the loss for a pair of quantum states and models using a circuit cost function.\n\nArguments\n\nstates::NTuple{2, ArrayReg}: The tuple of quantum states.\nmodels::NTuple{<:Any, AbstractModel}: The tuple of quantum models.\ncost::CircuitCost: The circuit cost function.\nlambda::Float64: The regularization parameter, default is 1.0.\nregularization::Symbol: The type of regularization (:l1 or :l2), default is :nothing.\n\nReturns\n\nFloat64: The evaluated loss.\n\n\n\n\n\neval_loss(states::NTuple{2, ArrayReg}, model::AbstractModel, cost::GeneralCost; lambda=1.0::Float64, regularization=:nothing::Symbol) -> Float64\n\nEvaluates the loss for a pair of quantum states and a model using a general cost function.\n\nArguments\n\nstates::NTuple{2, ArrayReg}: The tuple of quantum states.\nmodel::AbstractModel: The quantum model.\ncost::GeneralCost: The general cost function.\nlambda::Float64: The regularization parameter, default is 1.0.\nregularization::Symbol: The type of regularization (:l1 or :l2), default is :nothing.\n\nReturns\n\nFloat64: The evaluated loss.\n\n\n\n\n\neval_loss(states::NTuple{2, ArrayReg}, model::AbstractModel, cost::CircuitCost; lambda=1.0::Float64, regularization=:nothing::Symbol) -> Float64\n\nEvaluates the loss for a pair of quantum states and a model using a general cost function.\n\nArguments\n\nstates::NTuple{2, ArrayReg}: The tuple of quantum states.\nmodel::AbstractModel: The quantum model.\ncost::CircuitCost: The circuit cost function.\nlambda::Float64: The regularization parameter, default is 1.0.\nregularization::Symbol: The type of regularization (:l1 or :l2), default is :nothing.\n\nReturns\n\nFloat64: The evaluated loss.\n\n\n\n\n\neval_loss(state::ArrayReg, models::NTuple{2, AbstractModel}, cost::GeneralCost; lambda=1.0::Float64, regularization=:nothing::Symbol) -> Float64\n\nEvaluates the loss for a quantum state and a tuple of models using a general cost function.\n\nArguments\n\nstate::ArrayReg: The quantum state.\nmodels::NTuple{2, AbstractModel}: The tuple of quantum models.\ncost::GeneralCost: The general cost function.\nlambda::Float64: The regularization parameter, default is 1.0.\nregularization::Symbol: The type of regularization (:l1 or :l2), default is :nothing.\n\nReturns\n\nFloat64: The evaluated loss.\n\n\n\n\n\neval_loss(state::ArrayReg, models::NTuple{2, AbstractModel}, cost::CircuitCost; lambda=1.0::Float64, regularization=:nothing::Symbol) -> Float64\n\nEvaluates the loss for a quantum state and a tuple of models using a circuit cost function.\n\nArguments\n\nstate::ArrayReg: The quantum state.\nmodels::NTuple{2, AbstractModel}: The tuple of quantum models.\ncost::CircuitCost: The circuit cost function.\nlambda::Float64: The regularization parameter, default is 1.0.\nregularization::Symbol: The type of regularization (:l1 or :l2), default is :nothing.\n\nReturns\n\nFloat64: The evaluated loss.\n\n\n\n\n\n","category":"function"},{"location":"loss/#QuantumPrimer.eval_full_loss","page":"Loss","title":"QuantumPrimer.eval_full_loss","text":"eval_full_loss(data::AbstractData, model::Union{AbstractModel, NTuple{<:Any, AbstractModel}}, cost::AbstractCost; lambda=1.0::Float64, regularization=:nothing::Symbol) -> Float64\n\nEvaluates the full loss over a dataset for a given model or tuple of models.\n\nArguments\n\ndata::AbstractData: The dataset containing quantum states and corresponding labels.\nmodel::Union{AbstractModel, NTuple{<:Any, AbstractModel}}: The quantum model or tuple of models.\ncost::AbstractCost: The cost function.\nlambda::Float64: The regularization parameter, default is 1.0.\nregularization::Symbol: The type of regularization (:l1 or :l2), default is :nothing.\n\nReturns\n\nFloat64: The evaluated full loss.\n\n\n\n\n\n","category":"function"},{"location":"loss/#Loss-regularization","page":"Loss","title":"Loss regularization","text":"","category":"section"},{"location":"loss/","page":"Loss","title":"Loss","text":"regularize_loss","category":"page"},{"location":"loss/#QuantumPrimer.regularize_loss","page":"Loss","title":"QuantumPrimer.regularize_loss","text":"regularize_loss(loss::Float64, model::AbstractModel; lambda=1.0::Float64, regularization=:nothing::Symbol) -> Float64\n\nRegularizes the loss using L1 or L2 regularization.\n\nArguments\n\nloss::Float64: The initial loss value.\nmodel::AbstractModel: The quantum model.\nlambda::Float64: The regularization parameter, default is 1.0.\nregularization::Symbol: The type of regularization (:l1 or :l2), default is :nothing.\n\nReturns\n\nFloat64: The regularized loss.\n\n\n\n\n\n","category":"function"},{"location":"graph/#Graph-documentation","page":"Graph","title":"Graph documentation","text":"","category":"section"},{"location":"graph/#Structure","page":"Graph","title":"Structure","text":"","category":"section"},{"location":"graph/","page":"Graph","title":"Graph","text":"AbstractGraph\nGraph\nSignedGraph\nsort_lexicographic","category":"page"},{"location":"graph/#QuantumPrimer.AbstractGraph","page":"Graph","title":"QuantumPrimer.AbstractGraph","text":"AbstractGraph\n\nAn abstract type for representing graphs.\n\n\n\n\n\n","category":"type"},{"location":"graph/#QuantumPrimer.Graph","page":"Graph","title":"QuantumPrimer.Graph","text":"Graph{T<:Vector{Vector{TT}} where TT<:Integer}\n\nA mutable struct representing a graph.\n\nFields\n\nl::T: A vector of vectors representing the adjacency list of the graph.\n\nConstructor\n\nGraph(l): Creates a Graph instance with the given adjacency list l.\n\n\n\n\n\n","category":"type"},{"location":"graph/#QuantumPrimer.SignedGraph","page":"Graph","title":"QuantumPrimer.SignedGraph","text":"SignedGraph{T<:Vector{Vector{T}} where T<:Integer, TT<:Vector{TT} where TT<:Integer}\n\nA mutable struct representing a signed graph.\n\nFields\n\nl::T: A vector of vectors representing the adjacency list of the graph.\ns::TT: A vector of integers representing the signs of the edges.\n\nConstructor\n\nSignedGraph(l, s): Creates a SignedGraph instance with the given adjacency list l and edge signs s.\n\n\n\n\n\n","category":"type"},{"location":"graph/#QuantumPrimer.sort_lexicographic","page":"Graph","title":"QuantumPrimer.sort_lexicographic","text":"sort_lexicographic(vec::Vector{Vector{Int}}) -> Vector{Vector{Int}}\n\nSorts a vector of vectors lexicographically and removes duplicates.\n\nArguments\n\nvec::Vector{Vector{Int}}: The vector of vectors to be sorted.\n\nReturns\n\nVector{Vector{Int}}: The sorted and unique vector of vectors.\n\n\n\n\n\nsort_lexicographic(vec_l::Vector{Vector{Int}}, vec_s::Vector{Int}) -> Tuple{Vector{Vector{Int}}, Vector{Int}}\n\nSorts a vector of vectors lexicographically and a corresponding vector of integers.\n\nArguments\n\nvec_l::Vector{Vector{Int}}: The vector of vectors to be sorted.\nvec_s::Vector{Int}: The vector of integers to be sorted according to vec_l.\n\nReturns\n\nTuple{Vector{Vector{Int}}, Vector{Int}}: The sorted vectors.\n\n\n\n\n\nsort_lexicographic(arr::Array) -> Array\n\nSorts an array of arrays lexicographically.\n\nArguments\n\narr::Array: The array of arrays to be sorted.\n\nReturns\n\nArray: The sorted array of arrays.\n\n\n\n\n\n","category":"function"},{"location":"graph/#Line-graph","page":"Graph","title":"Line graph","text":"","category":"section"},{"location":"graph/","page":"Graph","title":"Graph","text":"create_line_graph","category":"page"},{"location":"graph/#QuantumPrimer.create_line_graph","page":"Graph","title":"QuantumPrimer.create_line_graph","text":"create_line_graph(G::AbstractGraph) -> Graph\n\nCreates the line graph of a given graph.\n\nArguments\n\nG::AbstractGraph: The input graph.\n\nReturns\n\nGraph: The line graph of the input graph.\n\nThrows\n\nAn error if the input graph has no edges.\n\n\n\n\n\ncreate_line_graph(G::SignedGraph) -> SignedGraph\n\nCreates the line graph of a given signed graph.\n\nArguments\n\nG::SignedGraph: The input signed graph.\n\nReturns\n\nSignedGraph: The line graph of the input signed graph.\n\nThrows\n\nAn error if the input graph has no edges.\n\n\n\n\n\n","category":"function"},{"location":"graph/#Mapping-to-Hamiltonian-thermal-state","page":"Graph","title":"Mapping to Hamiltonian thermal state","text":"","category":"section"},{"location":"graph/","page":"Graph","title":"Graph","text":"create_interaction_matrix\ncreate_hamiltonian_matrix\nfrom_string_to_matrix\nρ_gibbs\ncreate_purified_state","category":"page"},{"location":"graph/#QuantumPrimer.create_interaction_matrix","page":"Graph","title":"QuantumPrimer.create_interaction_matrix","text":"create_interaction_matrix(G::SignedGraph) -> Matrix{Int}\n\nCreates the interaction matrix of a given signed graph.\n\nArguments\n\nG::SignedGraph: The input signed graph.\n\nReturns\n\nMatrix{Int}: The interaction matrix of the input signed graph.\n\n\n\n\n\n","category":"function"},{"location":"graph/#QuantumPrimer.create_hamiltonian_matrix","page":"Graph","title":"QuantumPrimer.create_hamiltonian_matrix","text":"create_hamiltonian_matrix(A::Array{Int, 2}) -> Matrix{ComplexF64}\n\nCreates the Hamiltonian matrix for a given interaction matrix.\n\nArguments\n\nA::Array{Int, 2}: The interaction matrix.\n\nReturns\n\nMatrix{ComplexF64}: The Hamiltonian matrix.\n\n\n\n\n\n","category":"function"},{"location":"graph/#QuantumPrimer.from_string_to_matrix","page":"Graph","title":"QuantumPrimer.from_string_to_matrix","text":"from_string_to_matrix(vec::AbstractArray) -> Matrix{ComplexF64}\n\nConverts a vector of matrices (developed initially for Paulis) to a single matrix using the Kronecker product.\n\nArguments\n\nvec::AbstractArray: The vector of matrices.\n\nReturns\n\nMatrix{ComplexF64}: The resulting matrix.\n\n\n\n\n\n","category":"function"},{"location":"graph/#QuantumPrimer.ρ_gibbs","page":"Graph","title":"QuantumPrimer.ρ_gibbs","text":"ρ_gibbs(β::Real, matrix::AbstractMatrix) -> Matrix{ComplexF64}\n\nComputes the Gibbs state for a given Hamiltonian matrix at inverse temperature β.\n\nArguments\n\nβ::Real: The inverse temperature.\nmatrix::AbstractMatrix: The Hamiltonian matrix.\n\nReturns\n\nMatrix{ComplexF64}: The Gibbs state.\n\n\n\n\n\n","category":"function"},{"location":"graph/#QuantumPrimer.create_purified_state","page":"Graph","title":"QuantumPrimer.create_purified_state","text":"create_purified_state(β::Real, G::SignedGraph) -> ArrayReg\n\nCreates a purified quantum state for a given signed graph at inverse temperature β.\n\nArguments\n\nβ::Real: The inverse temperature.\nG::SignedGraph: The input signed graph.\n\nReturns\n\nArrayReg: The purified quantum state.\n\n\n\n\n\n","category":"function"},{"location":"graph/#Classification-functions","page":"Graph","title":"Classification functions","text":"","category":"section"},{"location":"graph/","page":"Graph","title":"Graph","text":"find_negative_eigs\nfind_degeneracy_gs\nclassify_state_degeneracy\nclassify_state_negative_spectrum\nclassify_state_frustration_index","category":"page"},{"location":"graph/#QuantumPrimer.find_negative_eigs","page":"Graph","title":"QuantumPrimer.find_negative_eigs","text":"find_negative_eigs(matrix::AbstractMatrix) -> Int\n\nFinds the number of negative eigenvalues of a given matrix.\n\nArguments\n\nmatrix::AbstractMatrix: The input matrix.\n\nReturns\n\nInt: The number of negative eigenvalues.\n\n\n\n\n\nfind_negative_eigs(G::SignedGraph) -> Int\n\nFinds the number of negative eigenvalues of the Hamiltonian matrix of a given signed graph.\n\nArguments\n\nG::SignedGraph: The input signed graph.\n\nReturns\n\nInt: The number of negative eigenvalues.\n\n\n\n\n\n","category":"function"},{"location":"graph/#QuantumPrimer.find_degeneracy_gs","page":"Graph","title":"QuantumPrimer.find_degeneracy_gs","text":"find_degeneracy_gs(matrix::AbstractMatrix) -> Int\n\nFinds the degeneracy of the ground state of a given matrix.\n\nArguments\n\nmatrix::AbstractMatrix: The input matrix.\n\nReturns\n\nInt: The degeneracy of the ground state.\n\n\n\n\n\nfind_degeneracy_gs(G::SignedGraph) -> Int\n\nFinds the degeneracy of the ground state of the Hamiltonian matrix of a given signed graph.\n\nArguments\n\nG::SignedGraph: The input signed graph.\n\nReturns\n\nInt: The degeneracy of the ground state.\n\n\n\n\n\n","category":"function"},{"location":"graph/#QuantumPrimer.classify_state_degeneracy","page":"Graph","title":"QuantumPrimer.classify_state_degeneracy","text":"classify_state_degeneracy(n::Int, label::Int; max_iter::Int=1000, use_line_graph::Bool=false) -> SignedGraph\n\nClassifies a random signed graph based on the degeneracy of its ground state.\n\nArguments\n\nn::Int: The number of vertices.\nlabel::Int: The label indicating the desired degeneracy classification (1 for high degeneracy, -1 for low degeneracy).\nmax_iter::Int: The maximum number of iterations to attempt, default is 1000.\nuse_line_graph::Bool: Whether to use the line graph of the random signed graph, default is false.\n\nReturns\n\nSignedGraph: The classified random signed graph.\n\nThrows\n\nAn error if a suitable graph cannot be generated within the maximum number of iterations.\n\n\n\n\n\n","category":"function"},{"location":"graph/#QuantumPrimer.classify_state_negative_spectrum","page":"Graph","title":"QuantumPrimer.classify_state_negative_spectrum","text":"classify_state_negative_spectrum(n::Int, label::Int; max_iter::Int=1000, use_line_graph::Bool=false) -> SignedGraph\n\nClassifies a random signed graph based on the number of negative eigenvalues in its Hamiltonian matrix.\n\nArguments\n\nn::Int: The number of vertices.\nlabel::Int: The label indicating the desired classification (1 for more than 3 negative eigenvalues, -1 for 3 or fewer negative eigenvalues).\nmax_iter::Int: The maximum number of iterations to attempt, default is 1000.\nuse_line_graph::Bool: Whether to use the line graph of the random signed graph, default is false.\n\nReturns\n\nSignedGraph: The classified random signed graph.\n\nThrows\n\nAn error if a suitable graph cannot be generated within the maximum number of iterations.\n\n\n\n\n\n","category":"function"},{"location":"graph/#QuantumPrimer.classify_state_frustration_index","page":"Graph","title":"QuantumPrimer.classify_state_frustration_index","text":"classify_state_frustration_index(n::Int, threshold::Int, label::Int; max_iter::Int=10000, use_line_graph::Bool=false) -> SignedGraph\n\nClassifies a random signed graph based on its frustration index.\n\nArguments\n\nn::Int: The number of vertices.\nthreshold::Int: The threshold for the frustration index.\nlabel::Int: The label indicating the desired classification (1 for frustration index above the threshold, -1 for frustration index below or equal to the threshold).\nmax_iter::Int: The maximum number of iterations to attempt, default is 10000.\nuse_line_graph::Bool: Whether to use the line graph of the random signed graph, default is false.\n\nReturns\n\nSignedGraph: The classified random signed graph.\n\nThrows\n\nAn error if a suitable graph cannot be generated within the maximum number of iterations.\n\n\n\n\n\n","category":"function"},{"location":"graph/#Frustration-index","page":"Graph","title":"Frustration index","text":"","category":"section"},{"location":"graph/","page":"Graph","title":"Graph","text":"find_cycles\nget_neighbors\ndfs_find_cycles!\nevaluate_cycles_signs\ncount_unbalanced_cycles\nfind_frustration_index\nbalance_signed_graph\nreduce_frustration_signed_graph","category":"page"},{"location":"graph/#QuantumPrimer.find_cycles","page":"Graph","title":"QuantumPrimer.find_cycles","text":"find_cycles(G::SignedGraph) -> Set{Tuple{Vector{Int}, Vector{Vector{Int}}}}\n\nFinds all cycles in a given signed graph using depth-first search.\n\nArguments\n\nG::SignedGraph: The input signed graph.\n\nReturns\n\nSet{Tuple{Vector{Int}, Vector{Vector{Int}}}}: A set of cycles, each represented as a tuple of vertex indices and edge paths.\n\n\n\n\n\n","category":"function"},{"location":"graph/#QuantumPrimer.get_neighbors","page":"Graph","title":"QuantumPrimer.get_neighbors","text":"get_neighbors(G::SignedGraph, vertex::Int) -> Vector{Int}\n\nGets the neighbors of a given vertex in a signed graph.\n\nArguments\n\nG::SignedGraph: The input signed graph.\nvertex::Int: The vertex for which to find neighbors.\n\nReturns\n\nVector{Int}: A vector of neighboring vertex indices.\n\n\n\n\n\n","category":"function"},{"location":"graph/#QuantumPrimer.dfs_find_cycles!","page":"Graph","title":"QuantumPrimer.dfs_find_cycles!","text":"dfs_find_cycles!(G::SignedGraph, current_vertex::Int, start_vertex::Int, visited::BitVector, path::Vector{Int}, edge_path::Vector{Vector{Int}}, cycles::Set{Tuple{Vector{Int}, Vector{Vector{Int}}}})\n\nPerforms a depth-first search to find all cycles in a signed graph.\n\nArguments\n\nG::SignedGraph: The input signed graph.\ncurrent_vertex::Int: The current vertex in the DFS.\nstart_vertex::Int: The starting vertex for the DFS.\nvisited::BitVector: A bit vector indicating visited vertices.\npath::Vector{Int}: The current path in the DFS.\nedge_path::Vector{Vector{Int}}: The current edge path in the DFS.\ncycles::Set{Tuple{Vector{Int}, Vector{Vector{Int}}}}: The set of found cycles.\n\n\n\n\n\n","category":"function"},{"location":"graph/#QuantumPrimer.evaluate_cycles_signs","page":"Graph","title":"QuantumPrimer.evaluate_cycles_signs","text":"evaluate_cycles_signs(G::SignedGraph) -> Vector{Int}\n\nEvaluates the product of signs for the cycles in a given signed graph.\n\nArguments\n\nG::SignedGraph: The input signed graph.\n\nReturns\n\nVector{Int}: A vector of signs for each cycle.\n\n\n\n\n\n","category":"function"},{"location":"graph/#QuantumPrimer.count_unbalanced_cycles","page":"Graph","title":"QuantumPrimer.count_unbalanced_cycles","text":"count_unbalanced_cycles(G::SignedGraph) -> Int\n\nCounts the number of unbalanced cycles in a given signed graph.\n\nArguments\n\nG::SignedGraph: The input signed graph.\n\nReturns\n\nInt: The number of unbalanced cycles.\n\n\n\n\n\n","category":"function"},{"location":"graph/#QuantumPrimer.find_frustration_index","page":"Graph","title":"QuantumPrimer.find_frustration_index","text":"find_frustration_index(G::SignedGraph) -> Tuple{Int, Vector{Int}}\n\nFinds the frustration index of a given signed graph by changing the sign of the edges and checking the number of unbalanced cycles.\n\nArguments\n\nG::SignedGraph: The input signed graph.\n\nReturns\n\nTuple{Int, Vector{Int}}: The frustration index and the corresponding sign changes.\n\n\n\n\n\n","category":"function"},{"location":"graph/#QuantumPrimer.balance_signed_graph","page":"Graph","title":"QuantumPrimer.balance_signed_graph","text":"balance_signed_graph(graph::SignedGraph) -> SignedGraph\n\nBalances a signed graph by adjusting the signs of the edges to make the frustration index zero.\n\nArguments\n\ngraph::SignedGraph: The input signed graph.\n\nReturns\n\nSignedGraph: The balanced signed graph.\n\n\n\n\n\n","category":"function"},{"location":"graph/#QuantumPrimer.reduce_frustration_signed_graph","page":"Graph","title":"QuantumPrimer.reduce_frustration_signed_graph","text":"reduce_frustration_signed_graph(graph::SignedGraph, target::Int) -> SignedGraph\n\nReduces the frustration index of a signed graph by \"flipping\" a target number of -1 in the sign_changes vector.\n\nArguments\n\ngraph::SignedGraph: The input signed graph.\ntarget::Int: The number of sign changes to reduce the frustration index.\n\nReturns\n\nSignedGraph: The signed graph with reduced frustration index.\n\n\n\n\n\n","category":"function"},{"location":"graph/#Utility-graph-function","page":"Graph","title":"Utility graph function","text":"","category":"section"},{"location":"graph/","page":"Graph","title":"Graph","text":"create_random_signed_graph\nplot_signed_graph","category":"page"},{"location":"graph/#QuantumPrimer.create_random_signed_graph","page":"Graph","title":"QuantumPrimer.create_random_signed_graph","text":"create_random_signed_graph(n::Int) -> SignedGraph\n\nCreates a random signed graph with n vertices.\n\nArguments\n\nn::Int: The number of vertices.\n\nReturns\n\nSignedGraph: The resulting random signed graph.\n\n\n\n\n\n","category":"function"},{"location":"graph/#QuantumPrimer.plot_signed_graph","page":"Graph","title":"QuantumPrimer.plot_signed_graph","text":"plot_signed_graph(graph::SignedGraph) -> Tuple{SimpleGraph, Vector{Tuple{Float64, Float64}}, Matrix{Symbol}}\n\nPlots a signed graph by creating a simple graph representation, a dataset of vertex positions, and an edge color matrix.\n\nArguments\n\ngraph::SignedGraph: The input signed graph.\n\nReturns\n\nTuple{SimpleGraph, Vector{Tuple{Float64, Float64}}, Matrix{Symbol}}: A tuple containing the simple graph, the dataset of vertex positions, and the edge color matrix.\n\n\n\n\n\n","category":"function"},{"location":"traintest/#Train-and-Test-documentation","page":"Train and Test","title":"Train and Test documentation","text":"","category":"section"},{"location":"traintest/","page":"Train and Test","title":"Train and Test","text":"test_model\ntrain_test_model","category":"page"},{"location":"traintest/#QuantumPrimer.test_model","page":"Train and Test","title":"QuantumPrimer.test_model","text":"test_model(data::AbstractData, model::Union{AbstractModel, NTuple{2, AbstractModel}}, cost::AbstractCost; lambda=1.0::Float64, regularization=:nothing::Symbol) -> Tuple{Vector{Float64}, Float64, Vector{Int}}\n\nTests a quantum model on a given dataset.\n\nArguments\n\ndata::AbstractData: The dataset containing quantum states and corresponding labels.\nmodel::Union{AbstractModel, NTuple{2, AbstractModel}}: The quantum model or tuple of models.\ncost::AbstractCost: The cost function.\nlambda::Float64: The regularization parameter, default is 1.0.\nregularization::Symbol: The type of regularization (:l1 or :l2), default is :nothing.\n\nReturns\n\nTuple{Vector{Float64}, Float64, Vector{Int}}: A tuple containing the model predictions, success rate, and indices of successful predictions.\n\n\n\n\n\n","category":"function"},{"location":"traintest/#QuantumPrimer.train_test_model","page":"Train and Test","title":"QuantumPrimer.train_test_model","text":"train_test_model(data1::AbstractData,\n                 data2::AbstractData,\n                 model::AbstractModel,\n                 cost::AbstractCost,\n                 iters::Int,\n                 optim::AbstractRule;\n                 lambda=0.2::Float64,\n                 regularization=:nothing::Symbol,\n                 verbose=false::Bool) -> Tuple{AbstractVector{T} where T<:Real, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}}\n\nTrains and tests a quantum model on given datasets.\n\nArguments\n\ndata1::AbstractData: The training dataset.\ndata2::AbstractData: The testing dataset.\nmodel::AbstractModel: The quantum model.\ncost::AbstractCost: The cost function.\niters::Int: The number of training iterations.\noptim::AbstractRule: The optimization rule.\nlambda::Float64: The regularization parameter, default is 0.2.\nregularization::Symbol: The type of regularization (:l1 or :l2), default is :nothing.\nverbose::Bool: Whether to print progress information, default is false.\n\nReturns\n\nTuple{AbstractVector{T} where T<:Real, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}}: A tuple containing the model parameters, loss track, training accuracy track, testing accuracy track, training predictions, and testing predictions.\n\n\n\n\n\ntrain_test_model(data1::AbstractData,\n                 data2::AbstractData,\n                 models::NTuple{<:Any, AbstractModel},\n                 cost::AbstractCost,\n                 iters::Int,\n                 optim::AbstractRule;\n                 lambda=0.2::Float64,\n                 regularization=:nothing::Symbol,\n                 verbose=false::Bool) -> Tuple{NTuple{<:Any, AbstractModel}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}}\n\nTrains and tests a tuple of quantum models on given datasets.\n\nArguments\n\ndata1::AbstractData: The training dataset.\ndata2::AbstractData: The testing dataset.\nmodels::NTuple{<:Any, AbstractModel}: The tuple of quantum models.\ncost::AbstractCost: The cost function.\niters::Int: The number of training iterations.\noptim::AbstractRule: The optimization rule.\nlambda::Float64: The regularization parameter, default is 0.2.\nregularization::Symbol: The type of regularization (:l1 or :l2), default is :nothing.\nverbose::Bool: Whether to print progress information, default is false.\n\nReturns\n\nTuple{NTuple{<:Any, AbstractModel}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}}: A tuple containing all models, loss track, training accuracy track, testing accuracy track, training predictions, and testing predictions.\n\n\n\n\n\n","category":"function"},{"location":"gradient/#Gradient-documentation","page":"Gradient","title":"Gradient documentation","text":"","category":"section"},{"location":"gradient/#Gradient-evaluation","page":"Gradient","title":"Gradient evaluation","text":"","category":"section"},{"location":"gradient/","page":"Gradient","title":"Gradient","text":"eval_grad\neval_full_grad","category":"page"},{"location":"gradient/#QuantumPrimer.eval_grad","page":"Gradient","title":"QuantumPrimer.eval_grad","text":"eval_grad(state::ArrayReg, model::AbstractModel, cost::CircuitCost; lambda=1.0::Float64, regularization=:nothing::Symbol) -> Vector{Float64}\n\nEvaluates the gradient of the cost function for a given quantum state and model.\n\nArguments\n\nstate::ArrayReg: The quantum state.\nmodel::AbstractModel: The quantum model.\ncost::CircuitCost: The cost function.\nlambda::Float64: The regularization parameter, default is 1.0.\nregularization::Symbol: The type of regularization (:l1 or :l2), default is :nothing.\n\nReturns\n\nVector{Float64}: The evaluated gradients.\n\n\n\n\n\neval_grad(states::NTuple{2, ArrayReg}, models::NTuple{2, AbstractModel}, cost::CircuitCost; lambda=1.0::Float64, regularization=:nothing::Symbol) -> Vector{Float64}\n\nEvaluates the gradient of the cost function for a pair of quantum states and models.\n\nArguments\n\nstates::NTuple{2, ArrayReg}: The tuple of quantum states.\nmodels::NTuple{2, AbstractModel}: The tuple of quantum models.\ncost::CircuitCost: The cost function.\nlambda::Float64: The regularization parameter, default is 1.0.\nregularization::Symbol: The type of regularization (:l1 or :l2), default is :nothing.\n\nReturns\n\nVector{Float64}: The evaluated gradients.\n\n\n\n\n\neval_grad(states::NTuple{2, ArrayReg}, models::NTuple{<:Any, AbstractModel}, cost::CircuitCost; lambda=1.0::Float64, regularization=:nothing::Symbol) -> Vector{Float64}\n\nEvaluates the gradient of the cost function for a pair of quantum states and models.\n\nArguments\n\nstates::NTuple{2, ArrayReg}: The tuple of quantum states.\nmodels::NTuple{<:Any, AbstractModel}: The tuple of quantum models.\ncost::CircuitCost: The cost function.\nlambda::Float64: The regularization parameter, default is 1.0.\nregularization::Symbol: The type of regularization (:l1 or :l2), default is :nothing.\n\nReturns\n\nVector{Float64}: The evaluated gradients.\n\n\n\n\n\neval_grad(states::NTuple{2, ArrayReg}, model::AbstractModel, cost::GeneralCost; epsilon=(π/2)::Float64, lambda=1.0::Float64, regularization=:nothing::Symbol) -> Vector{Float64}\n\nEvaluates the gradient of the general cost function for a pair of quantum states and a model.\n\nArguments\n\nstates::NTuple{2, ArrayReg}: The tuple of quantum states.\nmodel::AbstractModel: The quantum model.\ncost::GeneralCost: The general cost function.\nepsilon::Float64: The shift parameter, default is π/2.\nlambda::Float64: The regularization parameter, default is 1.0.\nregularization::Symbol: The type of regularization (:l1 or :l2), default is :nothing.\n\nReturns\n\nVector{Float64}: The evaluated gradients.\n\n\n\n\n\neval_grad(states::NTuple{2, ArrayReg}, model::AbstractModel, cost::CircuitCost; epsilon=(π/2)::Float64, lambda=1.0::Float64, regularization=:nothing::Symbol) -> Vector{Float64}\n\nEvaluates the gradient of the general cost function for a pair of quantum states and a model.\n\nArguments\n\nstates::NTuple{2, ArrayReg}: The tuple of quantum states.\nmodel::AbstractModel: The quantum model.\ncost::CircuitCost: The circuit cost function.\nepsilon::Float64: The shift parameter, default is π/2.\nlambda::Float64: The regularization parameter, default is 1.0.\nregularization::Symbol: The type of regularization (:l1 or :l2), default is :nothing.\n\nReturns\n\nVector{Float64}: The evaluated gradients.\n\n\n\n\n\neval_grad(state::ArrayReg, models::NTuple{2, AbstractModel}, cost::GeneralCost; lambda=1.0::Float64, regularization=:nothing::Symbol) -> Vector{Float64}\n\nEvaluates the gradient of the general cost function for a quantum state and a tuple of models.\n\nArguments\n\nstate::ArrayReg: The quantum state.\nmodels::NTuple{2, AbstractModel}: The tuple of quantum models.\ncost::GeneralCost: The general cost function.\nlambda::Float64: The regularization parameter, default is 1.0.\nregularization::Symbol: The type of regularization (:l1 or :l2), default is :nothing.\n\nReturns\n\nVector{Float64}: The evaluated gradients.\n\n\n\n\n\n","category":"function"},{"location":"gradient/#QuantumPrimer.eval_full_grad","page":"Gradient","title":"QuantumPrimer.eval_full_grad","text":"eval_full_grad(data::AbstractData, model::Union{AbstractModel, NTuple{<:Any, AbstractModel}}, cost::AbstractCost; lambda=1.0::Float64, regularization=:nothing::Symbol) -> Vector{Float64}\n\nEvaluates the full gradient of the cost function over a dataset for a given model or tuple of models.\n\nArguments\n\ndata::AbstractData: The dataset containing quantum states and corresponding labels.\nmodel::Union{AbstractModel, NTuple{<:Any, AbstractModel}}: The quantum model or tuple of models.\ncost::AbstractCost: The cost function.\nlambda::Float64: The regularization parameter, default is 1.0.\nregularization::Symbol: The type of regularization (:l1 or :l2), default is :nothing.\n\nReturns\n\nVector{Float64}: The evaluated full gradients.\n\n\n\n\n\n","category":"function"},{"location":"gradient/#Parameter-shift-rule","page":"Gradient","title":"Parameter shift rule","text":"","category":"section"},{"location":"gradient/","page":"Gradient","title":"Gradient","text":"parameter_shift_rule","category":"page"},{"location":"gradient/#QuantumPrimer.parameter_shift_rule","page":"Gradient","title":"QuantumPrimer.parameter_shift_rule","text":"parameter_shift_rule(obs::Union{ChainBlock, Add}, state::ArrayReg, model::AbstractModel; epsilon=(π/2)::Float64) -> Vector{ComplexF64}\n\nComputes the gradient of the expectation value of an observable using the parameter shift rule.\n\nArguments\n\nobs::Union{ChainBlock, Add}: The observable.\nstate::ArrayReg: The quantum state.\nmodel::AbstractModel: The quantum model.\nepsilon::Float64: The shift parameter, default is π/2.\n\nReturns\n\nVector{ComplexF64}: The computed gradients.\n\n\n\n\n\nparameter_shift_rule(obs::Union{ChainBlock, Add}, state::ArrayReg, model::AbstractModel; epsilon=(π/2)::Float64) -> Vector{ComplexF64}\n\nComputes the gradient of the expectation value of an observable using the parameter shift rule.\n\nArguments\n\nobs::Union{ChainBlock, Add}: The observable.\nstate::ArrayReg: The quantum state.\nmodel::AbstractModel: The quantum model.\nepsilon::Float64: The shift parameter, default is π/2.\n\nReturns\n\nVector{ComplexF64}: The computed gradients.\n\n\n\n\n\n","category":"function"},{"location":"gradient/#Gradient-regularization","page":"Gradient","title":"Gradient regularization","text":"","category":"section"},{"location":"gradient/","page":"Gradient","title":"Gradient","text":"regularize_grads","category":"page"},{"location":"gradient/#QuantumPrimer.regularize_grads","page":"Gradient","title":"QuantumPrimer.regularize_grads","text":"regularize_grads(grads::Vector{Float64}, model::AbstractModel; lambda=1.0::Float64, regularization=:nothing::Symbol) -> Vector{Float64}\n\nRegularizes the gradients using L1 or L2 regularization.\n\nArguments\n\ngrads::Vector{Float64}: The gradients to be regularized.\nmodel::AbstractModel: The quantum model.\nlambda::Float64: The regularization parameter, default is 1.0.\nregularization::Symbol: The type of regularization (:l1 or :l2), default is :nothing.\n\nReturns\n\nVector{Float64}: The regularized gradients.\n\n\n\n\n\nregularize_grads(grads::Vector{Float64}, models::NTuple{<:Any, AbstractModel}; lambda=1.0::Float64, regularization=:nothing::Symbol) -> Vector{Float64}\n\nRegularizes the gradients for a tuple of models using L1 or L2 regularization.\n\nArguments\n\ngrads::Vector{Float64}: The gradients to be regularized.\nmodels::NTuple{<:Any, AbstractModel}: The tuple of quantum models.\nlambda::Float64: The regularization parameter, default is 1.0.\nregularization::Symbol: The type of regularization (:l1 or :l2), default is :nothing.\n\nReturns\n\nVector{Float64}: The regularized gradients.\n\n\n\n\n\n","category":"function"},{"location":"utils/#Utility-documentation","page":"Utils","title":"Utility documentation","text":"","category":"section"},{"location":"utils/","page":"Utils","title":"Utils","text":"haar_random_unitary\nwasserstein_distance\nKL_divergence\nskewness\ndensity_matrix_from_vector\nregister_from_vector\npauli_decomposition","category":"page"},{"location":"utils/#QuantumPrimer.haar_random_unitary","page":"Utils","title":"QuantumPrimer.haar_random_unitary","text":"haar_random_unitary(n::Int) -> Matrix{ComplexF64}\n\nGenerates a Haar-random unitary matrix of size n x n.\n\nArguments\n\nn::Int: The size of the unitary matrix.\n\nReturns\n\nMatrix{ComplexF64}: The Haar-random unitary matrix.\n\n\n\n\n\n","category":"function"},{"location":"utils/#QuantumPrimer.wasserstein_distance","page":"Utils","title":"QuantumPrimer.wasserstein_distance","text":"wasserstein_distance(p::Vector{Float64}, q::Vector{Float64}) -> Float64\n\nComputes the Wasserstein distance between two probability distributions.\n\nArguments\n\np::Vector{Float64}: The first probability distribution.\nq::Vector{Float64}: The second probability distribution.\n\nReturns\n\nFloat64: The Wasserstein distance.\n\nThrows\n\nAn error if the input vectors are not valid probability distributions.\n\n\n\n\n\n","category":"function"},{"location":"utils/#QuantumPrimer.KL_divergence","page":"Utils","title":"QuantumPrimer.KL_divergence","text":"KL_divergence(p::Vector{Float64}, q::Vector{Float64}) -> Float64\n\nComputes the Kullback-Leibler (KL) divergence between two probability distributions.\n\nArguments\n\np::Vector{Float64}: The first probability distribution.\nq::Vector{Float64}: The second probability distribution.\n\nReturns\n\nFloat64: The KL divergence.\n\nThrows\n\nAn error if the input vectors are not valid probability distributions or if p and q have different lengths.\nAn error if p is non-zero where q is zero.\n\n\n\n\n\n","category":"function"},{"location":"utils/#QuantumPrimer.skewness","page":"Utils","title":"QuantumPrimer.skewness","text":"skewness(vec::Vector{Float64}) -> Float64\n\nComputes the skewness of a given vector.\n\nArguments\n\nvec::Vector{Float64}: The input vector.\n\nReturns\n\nFloat64: The skewness of the vector.\n\n\n\n\n\n","category":"function"},{"location":"utils/#QuantumPrimer.density_matrix_from_vector","page":"Utils","title":"QuantumPrimer.density_matrix_from_vector","text":"density_matrix_from_vector(states::Vector{Vector{Int}}; coeffs=nothing::Union{Nothing, Vector{Float64}})\n\nCreate a density matrix from a vector of integer vectors. Each integer vector is converted to an ArrayReg using bit_literal.\n\nArguments\n\nstates::Vector{Vector{Int}}: A vector of integer vectors to be included in the density matrix.\ncoeffs::Union{Nothing, Vector{Float64}}: Optional coefficients for the states. If provided, the coefficients are used in the density matrix calculation.\n\nReturns\n\nA density matrix created from the given integer vectors and coefficients.\n\n\n\n\n\n","category":"function"},{"location":"utils/#QuantumPrimer.register_from_vector","page":"Utils","title":"QuantumPrimer.register_from_vector","text":"register_from_vector(states::Vector{Vector{Int}}; coeffs=nothing::Union{Nothing, Vector{Float64}})\n\nCreate a quantum register from a vector of integer vectors. Each integer vector is converted to an ArrayReg using bit_literal.\n\nArguments\n\nstates::Vector{Vector{Int}}: A vector of integer vectors to be included in the register.\ncoeffs::Union{Nothing, Vector{Float64}}: Optional coefficients for the states. If provided, the coefficients are normalized.\n\nReturns\n\nA quantum register created from the given integer vectors and coefficients.\n\n\n\n\n\n","category":"function"},{"location":"utils/#QuantumPrimer.pauli_decomposition","page":"Utils","title":"QuantumPrimer.pauli_decomposition","text":"pauli_decomposition(matrix::Union{ChainBlock, Matrix{ComplexF64}, Matrix{T}} where T<:Real)\n\nDecompose a matrix into a dictionary of Pauli strings.\n\nArguments\n\nmatrix::Union{ChainBlock, Matrix{ComplexF64}, Matrix{T}} where T<:Real: The input matrix to be decomposed. The matrix must be square with dimensions 2^n x 2^n.\n\nReturns\n\nA dictionary where the keys are vectors of integers representing Pauli strings, and the values are the corresponding coefficients.\n\n\n\n\n\n","category":"function"},{"location":"qsp/#QSP-documentation","page":"QSP","title":"QSP documentation","text":"","category":"section"},{"location":"qsp/","page":"QSP","title":"QSP","text":"W\nS\nUsp\neval_Usp\nloss\npcp\nblock_encode2\nQSVT_square","category":"page"},{"location":"qsp/#QuantumPrimer.W","page":"QSP","title":"QuantumPrimer.W","text":"W(a::Float64) -> ChainBlock\n\nCreates a quantum circuit block for the W gate.\n\nArguments\n\na::Float64: The parameter for the W gate.\n\nReturns\n\nChainBlock: The quantum circuit block for the W gate.\n\n\n\n\n\n","category":"function"},{"location":"qsp/#QuantumPrimer.S","page":"QSP","title":"QuantumPrimer.S","text":"S(phi::Float64) -> Rz\n\nCreates a quantum gate for the S gate.\n\nArguments\n\nphi::Float64: The parameter for the S gate.\n\nReturns\n\nRz: The quantum gate for the S gate.\n\n\n\n\n\n","category":"function"},{"location":"qsp/#QuantumPrimer.Usp","page":"QSP","title":"QuantumPrimer.Usp","text":"Usp(phis::Vector{Float64}, a::Float64) -> ChainBlock\n\nCreates a quantum circuit for the Usp unitary.\n\nArguments\n\nphis::Vector{Float64}: The vector of phase parameters.\na::Float64: The parameter for the W gate.\n\nReturns\n\nChainBlock: The quantum circuit for the Usp unitary.\n\n\n\n\n\n","category":"function"},{"location":"qsp/#QuantumPrimer.eval_Usp","page":"QSP","title":"QuantumPrimer.eval_Usp","text":"eval_Usp(x::Float64, phis::Vector{Float64}) -> Float64\n\nEvaluates the Usp unitary for a given input and phase parameters.\n\nArguments\n\nx::Float64: The input parameter.\nphis::Vector{Float64}: The vector of phase parameters.\n\nReturns\n\nFloat64: The evaluated value of the Usp unitary.\n\n\n\n\n\n","category":"function"},{"location":"qsp/#QuantumPrimer.loss","page":"QSP","title":"QuantumPrimer.loss","text":"loss(target::Function, xs::Vector{Float64}, phis::Vector{Float64}) -> Float64\n\nComputes the loss function for a given target function, inputs, and phase parameters.\n\nArguments\n\ntarget::Function: The target function.\nxs::Vector{Float64}: The vector of input parameters.\nphis::Vector{Float64}: The vector of phase parameters.\n\nReturns\n\nFloat64: The computed loss.\n\n\n\n\n\n","category":"function"},{"location":"qsp/#QuantumPrimer.pcp","page":"QSP","title":"QuantumPrimer.pcp","text":"pcp(n::Int, phi::Float64) -> ChainBlock\n\nCreates a projected controlled phase gate.\n\nArguments\n\nn::Int: The number of qubits.\nphi::Float64: The phase parameter.\n\nReturns\n\nChainBlock: The quantum circuit block for the projected controlled phase gate.\n\n\n\n\n\n","category":"function"},{"location":"qsp/#QuantumPrimer.block_encode2","page":"QSP","title":"QuantumPrimer.block_encode2","text":"block_encode2(n::Int, A::AbstractMatrix) -> ChainBlock\n\nCreates a block encoding for a given matrix.\n\nArguments\n\nn::Int: The number of qubits.\nA::AbstractMatrix: The matrix to be block encoded.\n\nReturns\n\nChainBlock: The quantum circuit block for the block encoding.\n\n\n\n\n\n","category":"function"},{"location":"qsp/#QuantumPrimer.QSVT_square","page":"QSP","title":"QuantumPrimer.QSVT_square","text":"QSVT_square(n::Int, d::Int, phis::Vector{Float64}, A::AbstractMatrix) -> ChainBlock\n\nCreates a quantum singular value transformation (QSVT) circuit for a given matrix.\n\nArguments\n\nn::Int: The number of qubits.\nd::Int: The degree of the polynomial.\nphis::Vector{Float64}: The vector of phase parameters.\nA::AbstractMatrix: The matrix to be transformed.\n\nReturns\n\nChainBlock: The quantum circuit for the QSVT.\n\n\n\n\n\n","category":"function"},{"location":"model/#Model-documentation","page":"Model","title":"Model documentation","text":"","category":"section"},{"location":"model/#Structure","page":"Model","title":"Structure","text":"","category":"section"},{"location":"model/","page":"Model","title":"Model","text":"AbstractModel\nGeneralModel\nInvariantModel","category":"page"},{"location":"model/#QuantumPrimer.AbstractModel","page":"Model","title":"QuantumPrimer.AbstractModel","text":"AbstractModel\n\nAn abstract type for representing quantum models.\n\n\n\n\n\n","category":"type"},{"location":"model/#QuantumPrimer.GeneralModel","page":"Model","title":"QuantumPrimer.GeneralModel","text":"GeneralModel{NN<:Int, CC<:ChainBlock, AA<:Function, TT<:AbstractVector{T} where T<:Real}\n\nA mutable struct representing a general quantum model.\n\nFields\n\nn::NN: The number of qubits.\nn_layers::NN: The number of layers in the model, default is ceil(Int, log2(n)).\ncirc::CC: The quantum circuit.\nansatz::AA: The ansatz function.\nparams::TT: The parameters of the model, default is an empty vector.\n\nConstructor\n\nGeneralModel(n::NN, circ::CC, ansatz::AA; n_layers::NN=ceil(Int, log2(n)), params::TT=Float64[]): Creates a GeneralModel instance.\n\n\n\n\n\n","category":"type"},{"location":"model/#QuantumPrimer.InvariantModel","page":"Model","title":"QuantumPrimer.InvariantModel","text":"InvariantModel{NN<:Int, CC<:ChainBlock, AA<:Function, TT<:AbstractVector{T} where T<:Real}\n\nA mutable struct representing an invariant quantum model.\n\nFields\n\nn::NN: The number of qubits.\nn_layers::NN: The number of layers in the model, default is ceil(Int, log2(n)).\ncirc::CC: The quantum circuit.\nansatz::AA: The ansatz function.\nparams::TT: The parameters of the model, default is an empty vector.\n\nConstructor\n\nInvariantModel(n::NN, circ::CC, ansatz::AA; n_layers::NN=ceil(Int, log2(n)), params::TT=Float64[]): Creates an InvariantModel instance.\n\n\n\n\n\n","category":"type"},{"location":"model/#Parameter-functions","page":"Model","title":"Parameter functions","text":"","category":"section"},{"location":"model/","page":"Model","title":"Model","text":"initialize_params!\nexpand_params\nreduce_params","category":"page"},{"location":"model/#QuantumPrimer.initialize_params!","page":"Model","title":"QuantumPrimer.initialize_params!","text":"initialize_params!(model::GeneralModel)\n\nInitializes the parameters of a GeneralModel instance.\n\nArguments\n\nmodel::GeneralModel: The general quantum model.\n\nThrows\n\nAn error if the number of qubits is not a power of 2.\n\n\n\n\n\ninitialize_params!(model::InvariantModel)\n\nInitializes the parameters of an InvariantModel instance.\n\nArguments\n\nmodel::InvariantModel: The invariant quantum model.\n\nThrows\n\nAn error if the number of qubits is not a power of 2.\n\n\n\n\n\n","category":"function"},{"location":"model/#QuantumPrimer.expand_params","page":"Model","title":"QuantumPrimer.expand_params","text":"expand_params(model::GeneralModel) -> AbstractVector{T} where T<:Real\n\nExpands the parameters of a GeneralModel instance.\n\nArguments\n\nmodel::GeneralModel: The general quantum model.\n\nReturns\n\nAbstractVector{T} where T<:Real: The expanded parameters.\n\n\n\n\n\nexpand_params(model::InvariantModel) -> AbstractVector{T} where T<:Real\n\nExpands the parameters of an InvariantModel instance.\n\nArguments\n\nmodel::InvariantModel: The invariant quantum model.\n\nReturns\n\nAbstractVector{T} where T<:Real: The expanded parameters.\n\n\n\n\n\n","category":"function"},{"location":"model/#QuantumPrimer.reduce_params","page":"Model","title":"QuantumPrimer.reduce_params","text":"reduce_params(model::GeneralModel, vect::AbstractVector{T} where T<:Real) -> AbstractVector{T} where T<:Real\n\nReduces the parameters of a GeneralModel instance.\n\nArguments\n\nmodel::GeneralModel: The general quantum model.\nvect::AbstractVector{T} where T<:Real: The vector of parameters to be reduced.\n\nReturns\n\nAbstractVector{T} where T<:Real: The reduced parameters.\n\n\n\n\n\nreduce_params(model::InvariantModel, vect::AbstractVector{T} where T<:Real) -> AbstractVector{T} where T<:Real\n\nReduces the parameters of an InvariantModel instance.\n\nArguments\n\nmodel::InvariantModel: The invariant quantum model.\nvect::AbstractVector{T} where T<:Real: The vector of parameters to be reduced.\n\nReturns\n\nAbstractVector{T} where T<:Real: The reduced parameters.\n\n\n\n\n\n","category":"function"},{"location":"circuit/#Circuits-documentation","page":"Circuit","title":"Circuits documentation","text":"","category":"section"},{"location":"circuit/#Basic-circuits","page":"Circuit","title":"Basic circuits","text":"","category":"section"},{"location":"circuit/","page":"Circuit","title":"Circuit","text":"circ_gate_single\ncirc_gate_n\ncirc_gate_sum\ncirc_gate_where\ncirc_block_single\ncirc_block_n\ncirc_block_sum\ncirc_block_where\ncirc_X\ncirc_Y\ncirc_Z\ncirc_X_where\ncirc_Y_where\ncirc_Z_where\ncirc_Xn\ncirc_Yn\ncirc_Zn\ncirc_Xsum\ncirc_Ysum\ncirc_Zsum","category":"page"},{"location":"circuit/#QuantumPrimer.circ_gate_single","page":"Circuit","title":"QuantumPrimer.circ_gate_single","text":"circ_gate_single(n::Int, i::Int, gate::ConstantGate) -> ChainBlock\n\nCreates a quantum circuit with a single gate applied to the i-th qubit.\n\nArguments\n\nn::Int: The total number of qubits.\ni::Int: The index of the qubit to which the gate is applied.\ngate::ConstantGate: The gate to be applied.\n\nReturns\n\nChainBlock: The resulting quantum circuit.\n\n\n\n\n\n","category":"function"},{"location":"circuit/#QuantumPrimer.circ_gate_n","page":"Circuit","title":"QuantumPrimer.circ_gate_n","text":"circ_gate_n(n::Int, gate::ConstantGate) -> ChainBlock\n\nCreates a quantum circuit with the same gate applied to all qubits.\n\nArguments\n\nn::Int: The total number of qubits.\ngate::ConstantGate: The gate to be applied.\n\nReturns\n\nChainBlock: The resulting quantum circuit.\n\n\n\n\n\n","category":"function"},{"location":"circuit/#QuantumPrimer.circ_gate_sum","page":"Circuit","title":"QuantumPrimer.circ_gate_sum","text":"circ_gate_sum(n::Int, gate::ConstantGate) -> ChainBlock\n\nCreates a quantum circuit with the sum of the same gate applied to all qubits.\n\nArguments\n\nn::Int: The total number of qubits.\ngate::ConstantGate: The gate to be applied.\n\nReturns\n\nChainBlock: The resulting quantum circuit.\n\n\n\n\n\n","category":"function"},{"location":"circuit/#QuantumPrimer.circ_gate_where","page":"Circuit","title":"QuantumPrimer.circ_gate_where","text":"circ_gate_where(n::Int, gate::ConstantGate, ones_where::Vector{Int}) -> ChainBlock\n\nCreates a quantum circuit with the gate applied to specific qubits.\n\nArguments\n\nn::Int: The total number of qubits.\ngate::ConstantGate: The gate to be applied.\nones_where::Vector{Int}: The indices of the qubits to which the gate is applied.\n\nReturns\n\nChainBlock: The resulting quantum circuit.\n\n\n\n\n\n","category":"function"},{"location":"circuit/#QuantumPrimer.circ_block_single","page":"Circuit","title":"QuantumPrimer.circ_block_single","text":"circ_block_single(n::Int, i::Int, block::ChainBlock{2}) -> ChainBlock\n\nCreates a quantum circuit with a single block applied to the i-th qubit.\n\nArguments\n\nn::Int: The total number of qubits.\ni::Int: The index of the qubit to which the block is applied.\nblock::ChainBlock{2}: The block to be applied.\n\nReturns\n\nChainBlock: The resulting quantum circuit.\n\n\n\n\n\n","category":"function"},{"location":"circuit/#QuantumPrimer.circ_block_n","page":"Circuit","title":"QuantumPrimer.circ_block_n","text":"circ_block_n(n::Int, block::ChainBlock{2}) -> ChainBlock\n\nCreates a quantum circuit with the same block applied to all qubits.\n\nArguments\n\nn::Int: The total number of qubits.\nblock::ChainBlock{2}: The block to be applied.\n\nReturns\n\nChainBlock: The resulting quantum circuit.\n\n\n\n\n\n","category":"function"},{"location":"circuit/#QuantumPrimer.circ_block_sum","page":"Circuit","title":"QuantumPrimer.circ_block_sum","text":"circ_block_sum(n::Int, block::ChainBlock{2}) -> ChainBlock\n\nCreates a quantum circuit with the sum of the same block applied to all qubits.\n\nArguments\n\nn::Int: The total number of qubits.\nblock::ChainBlock{2}: The block to be applied.\n\nReturns\n\nChainBlock: The resulting quantum circuit.\n\n\n\n\n\n","category":"function"},{"location":"circuit/#QuantumPrimer.circ_block_where","page":"Circuit","title":"QuantumPrimer.circ_block_where","text":"circ_block_where(n::Int, block::ChainBlock{2}, ones_where::Vector{Int}) -> ChainBlock\n\nCreates a quantum circuit with the block applied to specific qubits.\n\nArguments\n\nn::Int: The total number of qubits.\nblock::ChainBlock{2}: The block to be applied.\nones_where::Vector{Int}: The indices of the qubits to which the block is applied.\n\nReturns\n\nChainBlock: The resulting quantum circuit.\n\n\n\n\n\n","category":"function"},{"location":"circuit/#QuantumPrimer.circ_X","page":"Circuit","title":"QuantumPrimer.circ_X","text":"circ_X(n::Int, i::Int) -> ChainBlock\n\nCreates a quantum circuit with an X gate applied to the i-th qubit.\n\nArguments\n\nn::Int: The total number of qubits.\ni::Int: The index of the qubit to which the X gate is applied.\n\nReturns\n\nChainBlock: The resulting quantum circuit.\n\n\n\n\n\ncirc_X(n::Int) -> ChainBlock\n\nCreates a quantum circuit with an X gate applied to the first qubit.\n\nArguments\n\nn::Int: The total number of qubits.\n\nReturns\n\nChainBlock: The resulting quantum circuit.\n\n\n\n\n\n","category":"function"},{"location":"circuit/#QuantumPrimer.circ_Y","page":"Circuit","title":"QuantumPrimer.circ_Y","text":"circ_Y(n::Int, i::Int) -> ChainBlock\n\nCreates a quantum circuit with a Y gate applied to the i-th qubit.\n\nArguments\n\nn::Int: The total number of qubits.\ni::Int: The index of the qubit to which the Y gate is applied.\n\nReturns\n\nChainBlock: The resulting quantum circuit.\n\n\n\n\n\ncirc_Y(n::Int) -> ChainBlock\n\nCreates a quantum circuit with a Y gate applied to the first qubit.\n\nArguments\n\nn::Int: The total number of qubits.\n\nReturns\n\nChainBlock: The resulting quantum circuit.\n\n\n\n\n\n","category":"function"},{"location":"circuit/#QuantumPrimer.circ_Z","page":"Circuit","title":"QuantumPrimer.circ_Z","text":"circ_Z(n::Int, i::Int) -> ChainBlock\n\nCreates a quantum circuit with a Z gate applied to the i-th qubit.\n\nArguments\n\nn::Int: The total number of qubits.\ni::Int: The index of the qubit to which the Z gate is applied.\n\nReturns\n\nChainBlock: The resulting quantum circuit.\n\n\n\n\n\ncirc_Z(n::Int) -> ChainBlock\n\nCreates a quantum circuit with a Z gate applied to the first qubit.\n\nArguments\n\nn::Int: The total number of qubits.\n\nReturns\n\nChainBlock: The resulting quantum circuit.\n\n\n\n\n\n","category":"function"},{"location":"circuit/#QuantumPrimer.circ_X_where","page":"Circuit","title":"QuantumPrimer.circ_X_where","text":"circ_X_where(n::Int, ones_where::Vector{Int}) -> ChainBlock\n\nCreates a quantum circuit with X gates applied to specific qubits.\n\nArguments\n\nn::Int: The total number of qubits.\nones_where::Vector{Int}: The indices of the qubits to which the X gates are applied.\n\nReturns\n\nChainBlock: The resulting quantum circuit.\n\n\n\n\n\n","category":"function"},{"location":"circuit/#QuantumPrimer.circ_Y_where","page":"Circuit","title":"QuantumPrimer.circ_Y_where","text":"circ_Y_where(n::Int, ones_where::Vector{Int}) -> ChainBlock\n\nCreates a quantum circuit with Y gates applied to specific qubits.\n\nArguments\n\nn::Int: The total number of qubits.\nones_where::Vector{Int}: The indices of the qubits to which the Y gates are applied.\n\nReturns\n\nChainBlock: The resulting quantum circuit.\n\n\n\n\n\n","category":"function"},{"location":"circuit/#QuantumPrimer.circ_Z_where","page":"Circuit","title":"QuantumPrimer.circ_Z_where","text":"circ_Z_where(n::Int, ones_where::Vector{Int}) -> ChainBlock\n\nCreates a quantum circuit with Z gates applied to specific qubits.\n\nArguments\n\nn::Int: The total number of qubits.\nones_where::Vector{Int}: The indices of the qubits to which the Z gates are applied.\n\nReturns\n\nChainBlock: The resulting quantum circuit.\n\n\n\n\n\n","category":"function"},{"location":"circuit/#QuantumPrimer.circ_Xn","page":"Circuit","title":"QuantumPrimer.circ_Xn","text":"circ_Xn(n::Int) -> ChainBlock\n\nCreates a quantum circuit with X gates applied to all qubits.\n\nArguments\n\nn::Int: The total number of qubits.\n\nReturns\n\nChainBlock: The resulting quantum circuit.\n\n\n\n\n\n","category":"function"},{"location":"circuit/#QuantumPrimer.circ_Yn","page":"Circuit","title":"QuantumPrimer.circ_Yn","text":"circ_Yn(n::Int) -> ChainBlock\n\nCreates a quantum circuit with Y gates applied to all qubits.\n\nArguments\n\nn::Int: The total number of qubits.\n\nReturns\n\nChainBlock: The resulting quantum circuit.\n\n\n\n\n\n","category":"function"},{"location":"circuit/#QuantumPrimer.circ_Zn","page":"Circuit","title":"QuantumPrimer.circ_Zn","text":"circ_Zn(n::Int) -> ChainBlock\n\nCreates a quantum circuit with Z gates applied to all qubits.\n\nArguments\n\nn::Int: The total number of qubits.\n\nReturns\n\nChainBlock: The resulting quantum circuit.\n\n\n\n\n\n","category":"function"},{"location":"circuit/#QuantumPrimer.circ_Xsum","page":"Circuit","title":"QuantumPrimer.circ_Xsum","text":"circ_Xsum(n::Int) -> ChainBlock\n\nCreates a quantum circuit with the sum of X gates applied to all qubits.\n\nArguments\n\nn::Int: The total number of qubits.\n\nReturns\n\nChainBlock: The resulting quantum circuit.\n\n\n\n\n\n","category":"function"},{"location":"circuit/#QuantumPrimer.circ_Ysum","page":"Circuit","title":"QuantumPrimer.circ_Ysum","text":"circ_Ysum(n::Int) -> ChainBlock\n\nCreates a quantum circuit with the sum of Y gates applied to all qubits.\n\nArguments\n\nn::Int: The total number of qubits.\n\nReturns\n\nChainBlock: The resulting quantum circuit.\n\n\n\n\n\n","category":"function"},{"location":"circuit/#QuantumPrimer.circ_Zsum","page":"Circuit","title":"QuantumPrimer.circ_Zsum","text":"circ_Zsum(n::Int) -> ChainBlock\n\nCreates a quantum circuit with the sum of Z gates applied to all qubits.\n\nArguments\n\nn::Int: The total number of qubits.\n\nReturns\n\nChainBlock: The resulting quantum circuit.\n\n\n\n\n\n","category":"function"},{"location":"circuit/#Convolutional-circuits","page":"Circuit","title":"Convolutional circuits","text":"","category":"section"},{"location":"circuit/","page":"Circuit","title":"Circuit","text":"circ_Ry_simple_conv\ncirc_Ry_conv\ncirc_SU4_conv","category":"page"},{"location":"circuit/#QuantumPrimer.circ_Ry_simple_conv","page":"Circuit","title":"QuantumPrimer.circ_Ry_simple_conv","text":"circ_Ry_simple_conv(n::Int, i::Int, j::Int) -> ChainBlock\n\nCreates a simple quantum circuit with Ry gates and a controlled-X gate.\n\nArguments\n\nn::Int: The total number of qubits.\ni::Int: The index of the first qubit.\nj::Int: The index of the second qubit.\n\nReturns\n\nChainBlock: The resulting quantum circuit.\n\n\n\n\n\n","category":"function"},{"location":"circuit/#QuantumPrimer.circ_Ry_conv","page":"Circuit","title":"QuantumPrimer.circ_Ry_conv","text":"circ_Ry_conv(n::Int, i::Int, j::Int) -> ChainBlock\n\nCreates a quantum circuit with multiple Ry gates and controlled-X gates.\n\nArguments\n\nn::Int: The total number of qubits.\ni::Int: The index of the first qubit.\nj::Int: The index of the second qubit.\n\nReturns\n\nChainBlock: The resulting quantum circuit.\n\n\n\n\n\n","category":"function"},{"location":"circuit/#QuantumPrimer.circ_SU4_conv","page":"Circuit","title":"QuantumPrimer.circ_SU4_conv","text":"circ_SU4_conv(n::Int, i::Int, j::Int) -> ChainBlock\n\nCreates a quantum circuit with SU(4) gates and controlled-X gates.\n\nArguments\n\nn::Int: The total number of qubits.\ni::Int: The index of the first qubit.\nj::Int: The index of the second qubit.\n\nReturns\n\nChainBlock: The resulting quantum circuit.\n\n\n\n\n\n","category":"function"},{"location":"circuit/#Layer-circuits","page":"Circuit","title":"Layer circuits","text":"","category":"section"},{"location":"circuit/","page":"Circuit","title":"Circuit","text":"circ_Rx_layer\ncirc_Ry_layer\ncirc_Rz_layer\ncirc_CNOT_layer\ncirc_CZ_layer","category":"page"},{"location":"circuit/#QuantumPrimer.circ_Rx_layer","page":"Circuit","title":"QuantumPrimer.circ_Rx_layer","text":"circ_Rx_layer(n::Int) -> ChainBlock\n\nCreates a quantum circuit layer with Rx gates applied to all qubits.\n\nArguments\n\nn::Int: The total number of qubits.\n\nReturns\n\nChainBlock: The resulting quantum circuit layer.\n\n\n\n\n\n","category":"function"},{"location":"circuit/#QuantumPrimer.circ_Ry_layer","page":"Circuit","title":"QuantumPrimer.circ_Ry_layer","text":"circ_Ry_layer(n::Int) -> ChainBlock\n\nCreates a quantum circuit layer with Ry gates applied to all qubits.\n\nArguments\n\nn::Int: The total number of qubits.\n\nReturns\n\nChainBlock: The resulting quantum circuit layer.\n\n\n\n\n\n","category":"function"},{"location":"circuit/#QuantumPrimer.circ_Rz_layer","page":"Circuit","title":"QuantumPrimer.circ_Rz_layer","text":"circ_Rz_layer(n::Int) -> ChainBlock\n\nCreates a quantum circuit layer with Rz gates applied to all qubits.\n\nArguments\n\nn::Int: The total number of qubits.\n\nReturns\n\nChainBlock: The resulting quantum circuit layer.\n\n\n\n\n\n","category":"function"},{"location":"circuit/#QuantumPrimer.circ_CNOT_layer","page":"Circuit","title":"QuantumPrimer.circ_CNOT_layer","text":"circ_CNOT_layer(n::Int) -> ChainBlock\n\nCreates a quantum circuit layer with CNOT gates applied between adjacent qubits.\n\nArguments\n\nn::Int: The total number of qubits.\n\nReturns\n\nChainBlock: The resulting quantum circuit layer.\n\n\n\n\n\n","category":"function"},{"location":"circuit/#QuantumPrimer.circ_CZ_layer","page":"Circuit","title":"QuantumPrimer.circ_CZ_layer","text":"circ_CZ_layer(n::Int) -> ChainBlock\n\nCreates a quantum circuit layer with CZ gates applied between adjacent qubits.\n\nArguments\n\nn::Int: The total number of qubits.\n\nReturns\n\nChainBlock: The resulting quantum circuit layer.\n\n\n\n\n\n","category":"function"},{"location":"circuit/#QNN-circuits","page":"Circuit","title":"QNN circuits","text":"","category":"section"},{"location":"circuit/","page":"Circuit","title":"Circuit","text":"circ_HEA\ncirc_HEA_real","category":"page"},{"location":"circuit/#QuantumPrimer.circ_HEA","page":"Circuit","title":"QuantumPrimer.circ_HEA","text":"circ_HEA(n::Int) -> ChainBlock\n\nCreates a Hardware Efficient Ansatz (HEA) quantum circuit.\n\nArguments\n\nn::Int: The total number of qubits.\n\nReturns\n\nChainBlock: The resulting quantum circuit.\n\n\n\n\n\n","category":"function"},{"location":"circuit/#QuantumPrimer.circ_HEA_real","page":"Circuit","title":"QuantumPrimer.circ_HEA_real","text":"circ_HEA_real(n::Int) -> ChainBlock\n\nCreates a Hardware Efficient Ansatz (HEA) quantum circuit. This version is for real-valued ground states.\n\nArguments\n\nn::Int: The total number of qubits.\n\nReturns\n\nChainBlock: The resulting quantum circuit.\n\n\n\n\n\n","category":"function"},{"location":"circuit/#Hypergraph-states-circuits","page":"Circuit","title":"Hypergraph states circuits","text":"","category":"section"},{"location":"circuit/","page":"Circuit","title":"Circuit","text":"circ_phase_flip\ncirc_hypergraph_state","category":"page"},{"location":"circuit/#QuantumPrimer.circ_phase_flip","page":"Circuit","title":"QuantumPrimer.circ_phase_flip","text":"circ_phase_flip(n::Int, x::Int) -> ChainBlock\n\nCreates a quantum circuit that performs a phase flip on the state x.\n\nArguments\n\nn::Int: The total number of qubits.\nx::Int: The state to be phase-flipped.\n\nReturns\n\nChainBlock: The resulting quantum circuit.\n\n\n\n\n\n","category":"function"},{"location":"circuit/#QuantumPrimer.circ_hypergraph_state","page":"Circuit","title":"QuantumPrimer.circ_hypergraph_state","text":"circ_hypergraph_state(vec::Vector{Int}) -> ChainBlock\n\nCreates a quantum circuit that prepares a hypergraph state.\n\nArguments\n\nvec::Vector{Int}: The vector representing the hypergraph state.\n\nReturns\n\nChainBlock: The resulting quantum circuit.\n\n\n\n\n\n","category":"function"},{"location":"circuit/#Measurement-circuits","page":"Circuit","title":"Measurement circuits","text":"","category":"section"},{"location":"circuit/","page":"Circuit","title":"Circuit","text":"circ_swap_decomposed\ncirc_swap_all\ncirc_swap_test\ncirc_destructive_swap_test\ncirc_obs_times_swap","category":"page"},{"location":"circuit/#QuantumPrimer.circ_swap_decomposed","page":"Circuit","title":"QuantumPrimer.circ_swap_decomposed","text":"circ_swap_decomposed(n::Int, i::Int, j::Int) -> ChainBlock\n\nCreates a quantum circuit that performs a decomposed SWAP operation between qubits i and j.\n\nArguments\n\nn::Int: The total number of qubits.\ni::Int: The index of the first qubit.\nj::Int: The index of the second qubit.\n\nReturns\n\nChainBlock: The resulting quantum circuit.\n\n\n\n\n\n","category":"function"},{"location":"circuit/#QuantumPrimer.circ_swap_all","page":"Circuit","title":"QuantumPrimer.circ_swap_all","text":"circ_swap_all(n::Int; decompose::Bool=false) -> ChainBlock\n\nCreates a quantum circuit that performs SWAP operations between pairs of qubits.\n\nArguments\n\nn::Int: The total number of qubits.\ndecompose::Bool: Whether to use the decomposed SWAP operation.\n\nReturns\n\nChainBlock: The resulting quantum circuit.\n\n\n\n\n\n","category":"function"},{"location":"circuit/#QuantumPrimer.circ_swap_test","page":"Circuit","title":"QuantumPrimer.circ_swap_test","text":"circ_swap_test(n::Int) -> ChainBlock\n\nCreates a quantum circuit that performs a SWAP test.\n\nArguments\n\nn::Int: The total number of qubits.\n\nReturns\n\nChainBlock: The resulting quantum circuit.\n\n\n\n\n\n","category":"function"},{"location":"circuit/#QuantumPrimer.circ_destructive_swap_test","page":"Circuit","title":"QuantumPrimer.circ_destructive_swap_test","text":"circ_destructive_swap_test(n::Int) -> ChainBlock\n\nCreates a quantum circuit that performs a destructive SWAP test.\n\nArguments\n\nn::Int: The total number of qubits.\n\nReturns\n\nChainBlock: The resulting quantum circuit.\n\n\n\n\n\n","category":"function"},{"location":"circuit/#QuantumPrimer.circ_obs_times_swap","page":"Circuit","title":"QuantumPrimer.circ_obs_times_swap","text":"circ_obs_times_swap(n::Int, obs::Union{ChainBlock, Add}) -> ChainBlock\n\nCreates a quantum circuit that performs an observable times SWAP operation.\n\nArguments\n\nn::Int: The total number of qubits.\nobs::Union{ChainBlock, Add}: The observable to be applied.\n\nReturns\n\nChainBlock: The resulting quantum circuit.\n\n\n\n\n\n","category":"function"},{"location":"circuit/#LCU","page":"Circuit","title":"LCU","text":"","category":"section"},{"location":"circuit/","page":"Circuit","title":"Circuit","text":"circ_LCU","category":"page"},{"location":"circuit/#QuantumPrimer.circ_LCU","page":"Circuit","title":"QuantumPrimer.circ_LCU","text":"circ_LCU(n::Int, U_vec::Vector{ChainBlock}; initial_layer::Bool=true, final_layer::Bool=true) -> ChainBlock\n\nCreates a quantum circuit that performs a Linear Combination of Unitaries (LCU) operation.\n\nArguments\n\nn::Int: The total number of qubits.\nU_vec::Vector{ChainBlock}: The vector of unitary operations.\ninitial_layer::Bool: Whether to include the initial layer of Hadamard gates.\nfinal_layer::Bool: Whether to include the final layer of Hadamard gates.\n\nReturns\n\nChainBlock: The resulting quantum circuit.\n\n\n\n\n\n","category":"function"},{"location":"circuit/#Haar-random-unitary","page":"Circuit","title":"Haar random unitary","text":"","category":"section"},{"location":"circuit/","page":"Circuit","title":"Circuit","text":"circ_haar_random_unitary","category":"page"},{"location":"circuit/#QuantumPrimer.circ_haar_random_unitary","page":"Circuit","title":"QuantumPrimer.circ_haar_random_unitary","text":"circ_haar_random_unitary(n::Int) -> ChainBlock\n\nGenerates a quantum circuit with a Haar-random unitary matrix of size 2^n x 2^n.\n\nArguments\n\nn::Int: The number of qubits.\n\nReturns\n\nChainBlock: The quantum circuit with the Haar-random unitary matrix.\n\n\n\n\n\n","category":"function"},{"location":"qcnn/#QCNN-documentation","page":"QCNN","title":"QCNN documentation","text":"","category":"section"},{"location":"qcnn/","page":"QCNN","title":"QCNN","text":"build_QCNN","category":"page"},{"location":"qcnn/#QuantumPrimer.build_QCNN","page":"QCNN","title":"QuantumPrimer.build_QCNN","text":"build_QCNN(n::Int; ansatz=circ_Ry_conv::Function) -> ChainBlock\n\nBuilds a Quantum Convolutional Neural Network (QCNN) circuit.\n\nArguments\n\nn::Int: The number of qubits.\nansatz::Function: The ansatz function to use for the convolutional layers, default is circ_Ry_conv.\n\nReturns\n\nChainBlock: The constructed QCNN circuit.\n\n\n\n\n\n","category":"function"},{"location":"differencing/#Differencing-documentation","page":"Differencing","title":"Differencing documentation","text":"","category":"section"},{"location":"differencing/#Covariance-measures","page":"Differencing","title":"Covariance measures","text":"","category":"section"},{"location":"differencing/","page":"Differencing","title":"Differencing","text":"covariance\ncovariance_siamese_commuting_obs","category":"page"},{"location":"differencing/#QuantumPrimer.covariance","page":"Differencing","title":"QuantumPrimer.covariance","text":"covariance(output::Symbol, state::Union{ArrayReg, Pair}, obs_A::Union{ChainBlock, Add}, obs_B::Union{ChainBlock, Add}) -> Float64\n\nComputes the covariance between two observables for a given quantum state.\n\nArguments\n\noutput::Symbol: Specifies whether to return the loss (:loss) or the gradient (:grad).\nstate::Union{ArrayReg, Pair}: The quantum state.\nobs_A::Union{ChainBlock, Add}: The first observable.\nobs_B::Union{ChainBlock, Add}: The second observable.\n\nReturns\n\nFloat64: The computed covariance or its gradient.\n\n\n\n\n\n","category":"function"},{"location":"differencing/#QuantumPrimer.covariance_siamese_commuting_obs","page":"Differencing","title":"QuantumPrimer.covariance_siamese_commuting_obs","text":"covariance_siamese_commuting_obs(output::Symbol, state1::Union{ArrayReg, Pair}, state2::Union{ArrayReg, Pair}, obs_A::Union{ChainBlock, Add}, obs_B::Union{ChainBlock, Add}; model=nothing::Union{AbstractModel, Nothing}) -> Float64\n\nComputes the covariance between two observables for a pair of quantum states, assuming the observables commute.\n\nArguments\n\noutput::Symbol: Specifies whether to return the loss (:loss) or the gradient (:grad).\nstate1::Union{ArrayReg, Pair}: The first quantum state.\nstate2::Union{ArrayReg, Pair}: The second quantum state.\nobs_A::Union{ChainBlock, Add}: The first observable.\nobs_B::Union{ChainBlock, Add}: The second observable.\nmodel::Union{AbstractModel, Nothing}: An optional model, default is nothing.\n\nReturns\n\nFloat64: The computed covariance or its gradient.\n\n\n\n\n\n","category":"function"},{"location":"differencing/#Kernel-measures","page":"Differencing","title":"Kernel measures","text":"","category":"section"},{"location":"differencing/","page":"Differencing","title":"Differencing","text":"projected_quantum_kernel","category":"page"},{"location":"differencing/#QuantumPrimer.projected_quantum_kernel","page":"Differencing","title":"QuantumPrimer.projected_quantum_kernel","text":"projected_quantum_kernel(state1::ArrayReg, state2::ArrayReg; gamma=1.0::Float64) -> Float64\n\nComputes the projected quantum kernel between two quantum states.\n\nArguments\n\nstate1::ArrayReg: The first quantum state.\nstate2::ArrayReg: The second quantum state.\ngamma::Float64: The gamma parameter for the kernel, default is 1.0.\n\nReturns\n\nFloat64: The computed kernel value.\n\n\n\n\n\n","category":"function"},{"location":"differencing/#SWAP-measures","page":"Differencing","title":"SWAP measures","text":"","category":"section"},{"location":"differencing/","page":"Differencing","title":"Differencing","text":"swap_test\ndestructive_swap_test","category":"page"},{"location":"differencing/#QuantumPrimer.swap_test","page":"Differencing","title":"QuantumPrimer.swap_test","text":"swap_test(state1::ArrayReg, state2::ArrayReg; nshots=1000::Int) -> Float64\n\nPerforms a SWAP test between two quantum states.\n\nArguments\n\nstate1::ArrayReg: The first quantum state.\nstate2::ArrayReg: The second quantum state.\nnshots::Int: The number of shots for the measurement, default is 1000.\n\nReturns\n\nFloat64: The result of the SWAP test.\n\n\n\n\n\n","category":"function"},{"location":"differencing/#QuantumPrimer.destructive_swap_test","page":"Differencing","title":"QuantumPrimer.destructive_swap_test","text":"destructive_swap_test(state1::ArrayReg, state2::ArrayReg; nshots=1000::Int) -> Float64\n\nPerforms a destructive SWAP test between two quantum states.\n\nArguments\n\nstate1::ArrayReg: The first quantum state.\nstate2::ArrayReg: The second quantum state.\nnshots::Int: The number of shots for the measurement, default is 1000.\n\nReturns\n\nFloat64: The result of the destructive SWAP test.\n\n\n\n\n\n","category":"function"},{"location":"differencing/#Entanglement-measures","page":"Differencing","title":"Entanglement measures","text":"","category":"section"},{"location":"differencing/","page":"Differencing","title":"Differencing","text":"entanglement_difference","category":"page"},{"location":"differencing/#QuantumPrimer.entanglement_difference","page":"Differencing","title":"QuantumPrimer.entanglement_difference","text":"entanglement_difference(state1::ArrayReg, state2::ArrayReg) -> Float64\n\nComputes the difference in entanglement between two quantum states.\n\nArguments\n\nstate1::ArrayReg: The first quantum state.\nstate2::ArrayReg: The second quantum state.\n\nReturns\n\nFloat64: The computed entanglement difference.\n\n\n\n\n\n","category":"function"},{"location":"vqe/#Variational-quantum-eigensolver-(VQE)-documentation","page":"VQE","title":"Variational quantum eigensolver (VQE) documentation","text":"","category":"section"},{"location":"vqe/","page":"VQE","title":"VQE","text":"circ_vqe","category":"page"},{"location":"vqe/#QuantumPrimer.circ_vqe","page":"VQE","title":"QuantumPrimer.circ_vqe","text":"circ_vqe(H::AbstractMatrix; ansatz=circ_HEA::Function, depth::Union{Symbol, Int}=:nothing, iters::Int=500, verbose::Bool=false)\n\nPrepare a quantum circuit to approximate the ground state of the Hamiltonian H, using the Variational Quantum Eigensolver (VQE) approach.\n\nArguments\n\ngraph::Graph: The graph from which the modified Laplacian matrix is derived.\n\nKeyword Arguments\n\ndepth::Union{Symbol, Int}=:nothing: The depth of the hardware-efficient ansatz (HEA) used in the circuit. If set to :nothing, the depth is automatically determined based on the logarithm of the number of nodes in the graph.\niters::Int=500: The number of iterations for the VQE optimization process.\nverbose::Bool=false: If true, prints the energy distance at every 50th iteration and at the beginning.\n\nReturns\n\nQuantumCircuit: The optimized quantum circuit that approximates the ground state of the modified Laplacian matrix.\n\n\n\n\n\n","category":"function"},{"location":"#QuantumPrimer-Documentation","page":"Home","title":"QuantumPrimer Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for the QuantumPrimer module.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QuantumPrimer is a Julia module for quantum computing and quantum machine learning tasks. Mainly based on Yao.jl to provide a comprehensive toolkit for building quantum neural networks and various quantum algorithms.","category":"page"},{"location":"#Dependencies","page":"Home","title":"Dependencies","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QuantumPrimer relies on the following Julia packages:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Yao\nRandom\nOptimisers\nLinearAlgebra\nStatistics\nCombinatorics\nForwardDiff\nKronecker\nGraphs","category":"page"},{"location":"#Modules","page":"Home","title":"Modules","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QNN: Implements Quantum Neural Networks.\nQCNN: Implements Quantum Convolutional Neural Networks.\nData: Handles data preparation and manipulation for quantum machine learning tasks.\nModel: Defines models and architectures for quantum machine learning.\nLoss: Contains loss functions used in training quantum models.\nGradient: Implements gradient calculation methods for quantum models.\nCost: Provides cost functions for evaluating quantum models.\nCircuit: Provides functionalities for building and manipulating quantum circuits.\nDifferencing: Provides methods for numerical differentiation.\nActivation: Contains various activation functions used in quantum neural networks.\nTrainTest: Handles training and testing of quantum models.\nQSP: Implements Quantum Signal Processing algorithms.\nGraph: Implements graph-based algorithms and structures.\nUtils: Contains utility functions and helpers.","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To use the QuantumPrimer package, include it in your Julia script:","category":"page"},{"location":"","page":"Home","title":"Home","text":"include(\"../src/QuantumPrimer.jl\")\nusing .QuantumPrimer","category":"page"}]
}
